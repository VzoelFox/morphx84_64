; ============================================================================
; MACHINE CODE EMITTER - x86-64 Instruction Encoding
; ============================================================================
; [AI_HINT: Encode AST instructions menjadi x86-64 machine code]
;
; Emitter bertanggung jawab untuk:
; 1. Lookup instruction dari Brainlib ISA
; 2. Encode REX prefix
; 3. Encode ModR/M byte
; 4. Encode immediate/displacement values
; 5. Write bytes ke output buffer

; ============================================================================
; CONSTANTS - Register Encoding
; ============================================================================

const REG_RAX 0
const REG_RCX 1
const REG_RDX 2
const REG_RBX 3
const REG_RSP 4
const REG_RBP 5
const REG_RSI 6
const REG_RDI 7
const REG_R8 8
const REG_R9 9
const REG_R10 10
const REG_R11 11
const REG_R12 12
const REG_R13 13
const REG_R14 14
const REG_R15 15

; REX prefix bits
const REX_W 0x48  ; 64-bit operand
const REX_R 0x44  ; Extension of ModR/M reg field
const REX_X 0x42  ; Extension of SIB index field
const REX_B 0x41  ; Extension of ModR/M r/m field

; ============================================================================
; EMITTER STATE
; ============================================================================

const Emitter_SIZE 40

struktur Emitter
    prop output_buffer 8    ; Pointer to output buffer
    prop output_pos 8       ; Current position in buffer
    prop output_size 8      ; Total buffer size
    prop symbol_table 8     ; Symbol table ptr
    prop current_offset 8   ; Current code offset
tutup_struktur

; ============================================================================
; EMITTER INITIALIZATION
; ============================================================================

fungsi emitter_new
    ; Input: rdi (output buffer size)
    ; Output: rax (Emitter ptr)
    ; [AI_HINT: Create new emitter instance]

    push r12
    mov r12, rdi ; buffer size

    ; Allocate Emitter struct
    mov rdi, Codegen_Emitter_SIZE
    call MorphLib_mem_alloc
    push rax ; emitter ptr

    ; Allocate output buffer
    mov rdi, r12
    call MorphLib_mem_alloc

    pop rbx ; emitter ptr
    push rbx

    ; Set buffer ptr
    mov [rbx], rax

    ; Set output_pos = 0
    add rbx, 8
    mov rcx, 0
    mov [rbx], rcx

    ; Set output_size
    add rbx, 8
    mov [rbx], r12

    ; symbol_table = 0 (for now)
    add rbx, 8
    mov [rbx], rcx

    ; current_offset = 0
    add rbx, 8
    mov [rbx], rcx

    pop rax
    pop r12
    ret
tutup_fungsi

; ============================================================================
; EMIT INSTRUCTION FROM AST
; ============================================================================

fungsi emitter_emit_instruction
    ; Input: rdi (Emitter ptr), rsi (AstInstruction ptr)
    ; Output: rax (bytes written)
    ; [AI_HINT: Emit satu instruction dari AST node]

    push r12
    push r13
    push r14
    push r15
    mov r12, rdi ; emitter
    mov r13, rsi ; instruction node

    ; Get mnemonic
    mov rbx, r13
    add rbx, 24
    mov r14, [rbx] ; mnemonic_ptr
    add rbx, 8
    mov r15, [rbx] ; mnemonic_len

    ; Get Operands
    mov rbx, r13
    add rbx, 40
    mov r8, [rbx] ; op1
    add rbx, 8
    mov r9, [rbx] ; op2

    ; Check mnemonic "mov"
    cmp r15, 3
    jika_sama
        mov rdi, r14
        movzx rax, [rdi]
        cmp rax, 109 ; 'm'
        jika_sama
            ; It's mov
            mov rdi, r12
            mov rsi, r8
            mov rdx, r9
            call Codegen_emitter_emit_mov
            lompat emit_done
        tutup_jika

        ; Check "ret"
        cmp rax, 114 ; 'r'
        jika_sama
            ; It's ret
            mov rdi, r12
            mov rsi, 0xC3
            call Codegen_emitter_write_byte
            lompat emit_done
        tutup_jika
    tutup_jika

    ; Check "syscall" (7 chars)
    cmp r15, 7
    jika_sama
        ; Assume syscall
        mov rdi, r12
        mov rsi, 0x0F
        call Codegen_emitter_write_byte
        mov rdi, r12
        mov rsi, 0x05
        call Codegen_emitter_write_byte
        lompat emit_done
    tutup_jika

    emit_done:
    mov rax, 0
    pop r15
    pop r14
    pop r13
    pop r12
    ret
tutup_fungsi

; ============================================================================
; EMIT MOV INSTRUCTION
; ============================================================================

fungsi emitter_emit_mov
    ; Input: rdi (Emitter), rsi (op1), rdx (op2)
    push r12
    push r13
    push r14
    mov r12, rdi
    mov r13, rsi ; op1
    mov r14, rdx ; op2

    ; Check op1 type
    mov rbx, r13
    add rbx, 24
    mov rax, [rbx] ; op1.kind (1=REG, 2=IMM)

    cmp rax, 1 ; REG
    jika_sama
        ; Dest is REG
        ; Get dest reg ID
        mov rbx, r13
        add rbx, 32
        mov rdi, [rbx] ; value_ptr
        add rbx, 8
        mov rsi, [rbx] ; value_len
        call Codegen_emitter_reg_to_id
        mov r8, rax ; dest reg id

        ; Check op2
        mov rbx, r14
        add rbx, 24
        mov rax, [rbx] ; op2.kind

        cmp rax, 2 ; IMM
        jika_sama
            ; MOV REG, IMM (B8+reg)
            ; REX.W
            mov rdi, r12
            mov rsi, 8 ; REX.W (64-bit operand)

            ; Check REX.B (if dest reg >= 8)
            cmp r8, 8
            jika_lebih_sama
                or rsi, 1 ; REX.B
                sub r8, 8
            tutup_jika
            call Codegen_emitter_encode_rex

            ; Opcode B8 + reg
            mov rax, 0xB8
            add rax, r8
            mov rdi, r12
            mov rsi, rax
            call Codegen_emitter_write_byte

            ; Immediate Value (64-bit)
            mov rbx, r14
            add rbx, 48
            mov rax, [rbx] ; value_num
            mov rdi, r12
            mov rsi, rax
            call Codegen_emitter_write_qword

            pop r14
            pop r13
            pop r12
            ret
        tutup_jika

        cmp rax, 1 ; REG
        jika_sama
            ; MOV REG, REG (89 /r)
            ; Get src reg ID
            mov rbx, r14
            add rbx, 32
            mov rdi, [rbx]
            add rbx, 8
            mov rsi, [rbx]
            call Codegen_emitter_reg_to_id
            mov r9, rax ; src reg id

            ; REX.W
            mov rdi, r12
            mov rsi, 8 ; REX.W

            ; REX.R (Src is reg in modrm)
            cmp r9, 8
            jika_lebih_sama
                or rsi, 4 ; REX.R
                sub r9, 8
            tutup_jika

            ; REX.B (Dest is rm in modrm)
            cmp r8, 8
            jika_lebih_sama
                or rsi, 1 ; REX.B
                sub r8, 8
            tutup_jika

            call Codegen_emitter_encode_rex

            ; Opcode 89
            mov rdi, r12
            mov rsi, 0x89
            call Codegen_emitter_write_byte

            ; ModRM (11 src dest) -> (11 reg rm)
            ; mod=3, reg=src(r9), rm=dest(r8)
            mov rdi, r12
            mov rsi, 3
            mov rdx, r9
            mov rcx, r8
            call Codegen_emitter_encode_modrm

            pop r14
            pop r13
            pop r12
            ret
        tutup_jika
    tutup_jika

    pop r14
    pop r13
    pop r12
    ret
tutup_fungsi

; ============================================================================
; WRITE QWORD
; ============================================================================

fungsi emitter_write_qword
    ; Input: rdi (Emitter), rsi (value)
    push r12
    push r13
    mov r12, rdi
    mov r13, rsi

    mov rdi, r12
    mov rsi, r13
    call Codegen_emitter_write_dword

    mov rdi, r12
    mov rsi, r13
    shr rsi, 32
    call Codegen_emitter_write_dword

    pop r13
    pop r12
    ret
tutup_fungsi

; ============================================================================
; WRITE BYTES TO OUTPUT
; ============================================================================

fungsi emitter_write_byte
    ; Input: rdi (Emitter ptr), rsi (byte value)
    ; [AI_HINT: Write single byte ke output buffer]

    push r12
    mov r12, rdi

    ; Get output buffer
    mov rax, [r12]

    ; Get current pos
    mov rbx, r12
    add rbx, 8
    mov rcx, [rbx]

    ; Write byte
    add rax, rcx
    movb [rax], rsi

    ; Increment pos
    inc rcx
    mov [rbx], rcx

    ; Increment current_offset
    mov rbx, r12
    add rbx, 32
    mov rax, [rbx]
    inc rax
    mov [rbx], rax

    pop r12
    ret
tutup_fungsi

fungsi emitter_write_dword
    ; Input: rdi (Emitter ptr), rsi (dword value)
    ; [AI_HINT: Write 4 bytes (little-endian)]

    push r12
    push r13
    mov r12, rdi
    mov r13, rsi

    ; Write byte 0
    mov rdi, r12
    mov rsi, r13
    and rsi, 0xFF
    call Codegen_emitter_write_byte

    ; Write byte 1
    mov rdi, r12
    mov rsi, r13
    shr rsi, 8
    and rsi, 0xFF
    call Codegen_emitter_write_byte

    ; Write byte 2
    mov rdi, r12
    mov rsi, r13
    shr rsi, 16
    and rsi, 0xFF
    call Codegen_emitter_write_byte

    ; Write byte 3
    mov rdi, r12
    mov rsi, r13
    shr rsi, 24
    and rsi, 0xFF
    call Codegen_emitter_write_byte

    pop r13
    pop r12
    ret
tutup_fungsi

; ============================================================================
; REGISTER NAME TO ID CONVERSION
; ============================================================================

fungsi emitter_reg_to_id
    ; Input: rdi (register name string ptr), rsi (length)
    ; Output: rax (register ID, or -1 if invalid)
    ; [AI_HINT: Convert "rax" -> 0, "rbx" -> 3, etc]

    push r12
    mov r12, rdi ; str ptr

    ; Check first char 'r'
    movzx rax, [r12]
    cmp rax, 114 ; 'r'
    jika_beda
        mov rax, -1
        pop r12
        ret
    tutup_jika

    ; Check second char
    mov rbx, r12
    inc rbx
    movzx rax, [rbx]

    cmp rax, 97 ; 'a'
    jika_sama
        mov rax, 0 ; rax
        pop r12
        ret
    tutup_jika
    cmp rax, 99 ; 'c'
    jika_sama
        mov rax, 1 ; rcx
        pop r12
        ret
    tutup_jika
    cmp rax, 100 ; 'd'
    jika_sama
        ; rdx or rdi?
        inc rbx
        movzx rax, [rbx]
        cmp rax, 120 ; 'x'
        jika_sama
            mov rax, 2 ; rdx
            pop r12
            ret
        tutup_jika
        mov rax, 7 ; rdi
        pop r12
        ret
    tutup_jika
    cmp rax, 98 ; 'b'
    jika_sama
        ; rbx or rbp?
        inc rbx
        movzx rax, [rbx]
        cmp rax, 120 ; 'x'
        jika_sama
            mov rax, 3 ; rbx
            pop r12
            ret
        tutup_jika
        mov rax, 5 ; rbp
        pop r12
        ret
    tutup_jika
    cmp rax, 115 ; 's'
    jika_sama
        ; rsp or rsi?
        inc rbx
        movzx rax, [rbx]
        cmp rax, 112 ; 'p'
        jika_sama
            mov rax, 4 ; rsp
            pop r12
            ret
        tutup_jika
        mov rax, 6 ; rsi
        pop r12
        ret
    tutup_jika

    ; r8-r15
    cmp rax, 56 ; '8'
    jika_sama
        mov rax, 8
        pop r12
        ret
    tutup_jika
    cmp rax, 57 ; '9'
    jika_sama
        mov rax, 9
        pop r12
        ret
    tutup_jika
    cmp rax, 49 ; '1'
    jika_sama
        ; 10-15
        inc rbx
        movzx rax, [rbx]
        sub rax, 48
        add rax, 10
        pop r12
        ret
    tutup_jika

    mov rax, -1
    pop r12
    ret
tutup_fungsi

; ============================================================================
; ENCODE REX PREFIX
; ============================================================================

fungsi emitter_encode_rex
    ; Input: rdi (Emitter ptr), rsi (flags: W|R|X|B)
    ; [AI_HINT: Emit REX prefix byte]

    push r12
    mov r12, rdi

    ; REX base = 0x40
    mov rax, 0x40
    or rax, rsi

    ; Write REX byte
    mov rdi, r12
    mov rsi, rax
    call Codegen_emitter_write_byte

    pop r12
    ret
tutup_fungsi

; ============================================================================
; ENCODE MODR/M BYTE
; ============================================================================

fungsi emitter_encode_modrm
    ; Input: rdi (Emitter ptr), rsi (mod), rdx (reg), rcx (rm)
    ; [AI_HINT: Emit ModR/M byte: [mod:2][reg:3][rm:3]]

    push r12
    mov r12, rdi

    ; ModR/M = (mod << 6) | (reg << 3) | rm
    shl rsi, 6
    shl rdx, 3
    or rsi, rdx
    or rsi, rcx

    ; Write ModR/M byte
    mov rdi, r12
    call Codegen_emitter_write_byte

    pop r12
    ret
tutup_fungsi
